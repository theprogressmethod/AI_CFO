{
  "name": "Financial Processor - Real Files",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-financials",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyOutput": "=data"
        }
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [100, 300],
      "webhookId": "process-financials"
    },
    {
      "parameters": {
        "operation": "spreadsheetFile",
        "options": {
          "includeEmptyCells": true,
          "headerRow": false,
          "range": "",
          "readAsString": true
        }
      },
      "id": "read-spreadsheet",
      "name": "Read Spreadsheet File",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 2,
      "position": [300, 300]
    },
    {
      "parameters": {
        "jsCode": "// Convert spreadsheet data to text format for AI\nconst items = $input.all();\nlet allSheetData = [];\n\nitems.forEach((item, fileIndex) => {\n  // Process each sheet in the file\n  if (item.json && item.json.data) {\n    const sheetData = item.json.data;\n    \n    // Convert to text table format\n    let textTable = `File ${fileIndex + 1}:\\n`;\n    \n    sheetData.forEach((row, rowIndex) => {\n      const rowValues = Object.values(row).join('\\t');\n      textTable += rowValues + '\\n';\n    });\n    \n    allSheetData.push(textTable);\n  } else if (Array.isArray(item.json)) {\n    // Handle array format\n    let textTable = `File ${fileIndex + 1}:\\n`;\n    \n    item.json.forEach(row => {\n      const rowValues = Object.values(row).join('\\t');\n      textTable += rowValues + '\\n';\n    });\n    \n    allSheetData.push(textTable);\n  }\n});\n\n// Combine all sheets\nconst combinedData = allSheetData.join('\\n\\n---\\n\\n');\n\nreturn [{json: {spreadsheetData: combinedData}}];"
      },
      "id": "prepare-for-ai",
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4-turbo-preview",
          "mode": "list"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a financial data transformation expert. Transform financial statements (Income Statements and Balance Sheets) from various formats into a standardized long format.\n\nIMPORTANT RULES:\n1. Each cell value becomes a separate row\n2. Convert from wide format (months as columns) to long format\n3. Identify the statement type from the data\n4. Maintain account hierarchy\n\nRequired output columns for EVERY row:\n- \"Date Concat\": Month Year (e.g., \"Jan 2023\")\n- \"Year\": 4-digit year string (e.g., \"2023\")\n- \"Month\": Numeric month string (e.g., \"1\" for January)\n- \"Financial Statements\": Either \"Income Statement\" or \"Balance Sheet\"\n- \"Parent Account\": The category/parent (e.g., \"Revenue\", \"COGS\", \"Cash & Cash Equivalents\")\n- \"Account\": The specific line item name\n- \"Attribute\": Date in M/D/YYYY format (e.g., \"1/1/2023\")\n- \"Value\": Dollar amount with $ and commas (e.g., \"$400,000\" or \"-$350,000\")\n\nPARSING GUIDELINES:\n- First row often contains months (Jan 2023, Feb 2023, etc.)\n- First column usually contains account names\n- Identify Income Statement by: Revenue, COGS, Expenses, Net Income\n- Identify Balance Sheet by: Assets, Liabilities, Cash, Inventory\n- Keep negative values with minus sign\n- Skip empty rows and totals if needed\n- Group accounts under logical parents (Revenue, COGS, Operating Expenses, Assets, Liabilities)\n\nReturn ONLY a valid JSON array. No explanations."
            },
            {
              "role": "user",
              "content": "=Transform this financial data into the standardized format. Parse all months and all accounts:\n\n{{ $json.spreadsheetData }}\n\nReturn a JSON array with all data points transformed into the standard format."
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "temperature": 0.1,
          "maxTokens": 16000
        }
      },
      "id": "ai-transform",
      "name": "AI Transform",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.3,
      "position": [700, 300],
      "credentials": {
        "openAiApi": {
          "id": "YOUR_OPENAI_CREDENTIALS_ID",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract and clean the AI response\nconst aiResponse = $input.first().json;\n\nlet finalData = [];\n\n// Handle different response formats from OpenAI\nif (aiResponse.message) {\n  // If response is in message property\n  if (typeof aiResponse.message === 'string') {\n    try {\n      finalData = JSON.parse(aiResponse.message);\n    } catch (e) {\n      // Try to extract JSON from the string\n      const jsonMatch = aiResponse.message.match(/\\[.*\\]/s);\n      if (jsonMatch) {\n        finalData = JSON.parse(jsonMatch[0]);\n      }\n    }\n  } else if (Array.isArray(aiResponse.message)) {\n    finalData = aiResponse.message;\n  }\n} else if (aiResponse.content) {\n  // If response is in content property\n  if (typeof aiResponse.content === 'string') {\n    try {\n      finalData = JSON.parse(aiResponse.content);\n    } catch (e) {\n      const jsonMatch = aiResponse.content.match(/\\[.*\\]/s);\n      if (jsonMatch) {\n        finalData = JSON.parse(jsonMatch[0]);\n      }\n    }\n  } else if (Array.isArray(aiResponse.content)) {\n    finalData = aiResponse.content;\n  }\n} else if (Array.isArray(aiResponse)) {\n  // Direct array response\n  finalData = aiResponse;\n} else if (aiResponse.choices && aiResponse.choices[0]) {\n  // OpenAI API response format\n  const messageContent = aiResponse.choices[0].message?.content || aiResponse.choices[0].text;\n  if (messageContent) {\n    try {\n      finalData = JSON.parse(messageContent);\n    } catch (e) {\n      const jsonMatch = messageContent.match(/\\[.*\\]/s);\n      if (jsonMatch) {\n        finalData = JSON.parse(jsonMatch[0]);\n      }\n    }\n  }\n}\n\n// Ensure data is properly formatted\nif (!Array.isArray(finalData)) {\n  finalData = [finalData];\n}\n\n// Clean and validate each row\nconst cleanedData = finalData.map(row => ({\n  \"Date Concat\": row[\"Date Concat\"] || \"\",\n  \"Year\": row[\"Year\"] || \"\",\n  \"Month\": row[\"Month\"] || \"\",\n  \"Financial Statements\": row[\"Financial Statements\"] || \"\",\n  \"Parent Account\": row[\"Parent Account\"] || \"\",\n  \"Account\": row[\"Account\"] || \"\",\n  \"Attribute\": row[\"Attribute\"] || \"\",\n  \"Value\": row[\"Value\"] || \"\"\n}));\n\n// Return as JSON string for response\nreturn [{json: {data: JSON.stringify(cleanedData)}}];"
      },
      "id": "clean-response",
      "name": "Clean Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.data }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1100, 300]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Read Spreadsheet File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Spreadsheet File": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "AI Transform",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Transform": {
      "main": [
        [
          {
            "node": "Clean Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "real-files-v1",
  "id": "financial-processor-real",
  "tags": []
}