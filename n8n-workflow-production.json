{
  "name": "Financial Processor - Production",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-financials",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [100, 300],
      "webhookId": "process-financials"
    },
    {
      "parameters": {
        "operation": "spreadsheetFile",
        "binaryPropertyName": "file",
        "options": {
          "includeEmptyCells": false,
          "headerRow": true,
          "readAsString": true,
          "range": ""
        }
      },
      "id": "read-excel",
      "name": "Read Excel",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 2,
      "position": [300, 300]
    },
    {
      "parameters": {
        "jsCode": "// Convert spreadsheet data to text for AI processing\nconst items = $input.all();\nlet textOutput = '';\n\nitems.forEach((item, fileIndex) => {\n  if (fileIndex > 0) textOutput += '\\n\\n--- NEXT FILE ---\\n\\n';\n  \n  // Get the filename if available\n  const fileName = item.binary?.file?.fileName || `File ${fileIndex + 1}`;\n  textOutput += `File: ${fileName}\\n\\n`;\n  \n  // Process the JSON data\n  const data = item.json;\n  \n  if (Array.isArray(data)) {\n    // If data is an array of objects (rows)\n    if (data.length > 0) {\n      // Get headers\n      const headers = Object.keys(data[0]);\n      textOutput += headers.join('\\t') + '\\n';\n      \n      // Add each row\n      data.forEach(row => {\n        const values = headers.map(h => row[h] || '');\n        textOutput += values.join('\\t') + '\\n';\n      });\n    }\n  } else if (typeof data === 'object') {\n    // If data is an object, try to extract table structure\n    const allRows = [];\n    const headers = new Set();\n    \n    // Collect all data and headers\n    Object.entries(data).forEach(([key, value]) => {\n      if (typeof value === 'object') {\n        Object.keys(value).forEach(k => headers.add(k));\n        allRows.push({rowHeader: key, ...value});\n      }\n    });\n    \n    if (allRows.length > 0) {\n      const headerArray = ['Account', ...Array.from(headers)];\n      textOutput += headerArray.join('\\t') + '\\n';\n      \n      allRows.forEach(row => {\n        const values = headerArray.map(h => {\n          if (h === 'Account') return row.rowHeader;\n          return row[h] || '';\n        });\n        textOutput += values.join('\\t') + '\\n';\n      });\n    } else {\n      // Fallback: just stringify the data\n      textOutput += JSON.stringify(data, null, 2);\n    }\n  }\n});\n\nconsole.log('Prepared data (first 500 chars):', textOutput.substring(0, 500));\n\nreturn [{json: {spreadsheetData: textOutput}}];"
      },
      "id": "prepare-data",
      "name": "Prepare Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a financial data expert. Transform financial statements into standardized long format.\n\nRULES:\n1. Identify statement type:\n   - Income Statement: Has Revenue, COGS, Gross Profit, Operating Expenses, Net Income\n   - Balance Sheet: Has Assets, Liabilities, Cash, Inventory, Equity\n\n2. Parse structure:\n   - Column headers are usually months/dates (Jan 2023, Feb 2023, etc.)\n   - Row headers are account names\n   - Each cell value becomes one output row\n\n3. Output format - EXACTLY these columns:\n   - \"Date Concat\": Month Year like \"Jan 2023\"\n   - \"Year\": Year as string like \"2023\"\n   - \"Month\": Month number as string like \"1\" for January\n   - \"Financial Statements\": Either \"Income Statement\" or \"Balance Sheet\"\n   - \"Parent Account\": Category (Revenue, COGS, Assets, Liabilities, etc.)\n   - \"Account\": The specific line item\n   - \"Attribute\": Date as M/D/YYYY like \"1/1/2023\"\n   - \"Value\": Dollar amount with $ and commas like \"$123,456\"\n\n4. Parent Account mapping:\n   Income Statement:\n   - Revenue items → \"Revenue\"\n   - Cost items → \"COGS\"\n   - Operating expenses → \"Operating Expenses\"\n   - Tax items → \"Taxes\"\n   - Bottom line → \"Net Income\"\n   \n   Balance Sheet:\n   - Cash items → \"Cash & Cash Equivalents\"\n   - AR → \"Accounts Receivable\"\n   - Inventory → \"Inventory\"\n   - Fixed assets → \"Fixed Assets\"\n   - Current liabilities → \"Current Liabilities\"\n   - Long term debt → \"Long Term Liabilities\"\n   - Equity items → \"Equity\"\n\nReturn ONLY a JSON array. Transform ALL data points."
            },
            {
              "role": "user",
              "content": "Transform this financial data into standardized format:\n\n{{ $json.spreadsheetData }}\n\nParse every month column and every account row. Return JSON array only."
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "temperature": 0.1,
          "maxTokens": 16000
        }
      },
      "id": "ai-transform",
      "name": "AI Transform",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.3,
      "position": [700, 300],
      "credentials": {
        "openAiApi": {
          "id": "YOUR_OPENAI_CREDENTIALS_ID",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Clean and validate AI response\nconst input = $input.first().json;\nlet finalData = [];\n\n// Extract data from various possible formats\nif (typeof input === 'string') {\n  try {\n    finalData = JSON.parse(input);\n  } catch (e) {\n    console.error('String parse error:', e);\n    // Try to extract JSON array from string\n    const match = input.match(/\\[(?:[^\\[\\]]*|\\[(?:[^\\[\\]]*|\\[.*?\\])*\\])*\\]/s);\n    if (match) {\n      try {\n        finalData = JSON.parse(match[0]);\n      } catch (e2) {\n        console.error('Extracted JSON parse error:', e2);\n      }\n    }\n  }\n} else if (Array.isArray(input)) {\n  finalData = input;\n} else if (input && typeof input === 'object') {\n  // Check various property names OpenAI might use\n  const possibleProps = ['message', 'content', 'result', 'data', 'output'];\n  for (const prop of possibleProps) {\n    if (input[prop]) {\n      if (typeof input[prop] === 'string') {\n        try {\n          finalData = JSON.parse(input[prop]);\n          break;\n        } catch (e) {\n          continue;\n        }\n      } else if (Array.isArray(input[prop])) {\n        finalData = input[prop];\n        break;\n      }\n    }\n  }\n}\n\n// Ensure we have an array\nif (!Array.isArray(finalData)) {\n  console.error('Final data is not an array:', typeof finalData);\n  finalData = [];\n}\n\n// Clean and validate each row\nconst cleanedData = finalData\n  .filter(row => row && typeof row === 'object')\n  .map(row => ({\n    \"Date Concat\": String(row[\"Date Concat\"] || ''),\n    \"Year\": String(row[\"Year\"] || row.year || ''),\n    \"Month\": String(row[\"Month\"] || row.month || ''),\n    \"Financial Statements\": String(row[\"Financial Statements\"] || row.financial_statements || ''),\n    \"Parent Account\": String(row[\"Parent Account\"] || row.parent_account || ''),\n    \"Account\": String(row[\"Account\"] || row.account || ''),\n    \"Attribute\": String(row[\"Attribute\"] || row.attribute || ''),\n    \"Value\": String(row[\"Value\"] || row.value || '')\n  }));\n\nconsole.log(`Returning ${cleanedData.length} cleaned rows`);\n\n// Return as JSON string for the response\nreturn [{json: {data: JSON.stringify(cleanedData)}}];"
      },
      "id": "clean-response",
      "name": "Clean Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.data }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1100, 300]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Read Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Excel": {
      "main": [
        [
          {
            "node": "Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Data": {
      "main": [
        [
          {
            "node": "AI Transform",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Transform": {
      "main": [
        [
          {
            "node": "Clean Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "production-v1",
  "id": "financial-processor-production",
  "tags": []
}