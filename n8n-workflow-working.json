{
  "name": "Financial Processor - Working",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-financials",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "3d729693-7fa1-403e-b399-b8fbb37f980e",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "process-financials"
    },
    {
      "parameters": {
        "jsCode": "// Fix binary field\nconst items = $input.all();\nitems.forEach(item => {\n  if (item.binary) {\n    const binaryKeys = Object.keys(item.binary);\n    if (binaryKeys.length > 0 && !item.binary.data) {\n      item.binary.data = item.binary[binaryKeys[0]];\n    }\n  }\n});\nreturn items;"
      },
      "id": "bf110b3a-48bc-44ac-9fb7-ec501ac7167c",
      "name": "Fix Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },
    {
      "parameters": {
        "operation": "spreadsheetFile",
        "binaryPropertyName": "data",
        "options": {
          "includeEmptyCells": true,
          "headerRow": false,
          "readAsString": true,
          "rawData": true
        }
      },
      "id": "8faf9090-9f3c-40f8-a8b7-0beaed7deaa4",
      "name": "Read Excel",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 2,
      "position": [550, 300]
    },
    {
      "parameters": {
        "jsCode": "// Convert spreadsheet to readable text for AI\nconst items = $input.all();\nlet combinedText = '';\n\nconsole.log(`Processing ${items.length} items`);\n\nitems.forEach((item, idx) => {\n  const fileName = item.binary?.data?.fileName || `Sheet ${idx + 1}`;\n  const data = item.json;\n  \n  console.log(`Item ${idx} structure:`, {\n    isArray: Array.isArray(data),\n    isObject: typeof data === 'object',\n    keys: data ? Object.keys(data).slice(0, 10) : [],\n    sampleKey: data ? Object.keys(data)[0] : null,\n    sampleValue: data && Object.keys(data)[0] ? data[Object.keys(data)[0]] : null\n  });\n  \n  let sheetContent = '';\n  \n  // Handle column-based structure (keys are column numbers)\n  if (data && typeof data === 'object' && !Array.isArray(data)) {\n    const columnKeys = Object.keys(data).sort((a, b) => parseInt(a) - parseInt(b));\n    \n    // Find the maximum number of rows across all columns\n    let maxRows = 0;\n    const columnData = {};\n    \n    columnKeys.forEach(colKey => {\n      const column = data[colKey];\n      if (column && typeof column === 'object') {\n        const rowKeys = Object.keys(column);\n        columnData[colKey] = { data: column, rowKeys };\n        maxRows = Math.max(maxRows, rowKeys.length);\n      }\n    });\n    \n    console.log(`Found ${columnKeys.length} columns with max ${maxRows} rows`);\n    \n    // Build rows by iterating through each row index\n    for (let rowIdx = 0; rowIdx < maxRows; rowIdx++) {\n      const rowValues = [];\n      \n      columnKeys.forEach(colKey => {\n        const col = columnData[colKey];\n        if (col && col.rowKeys[rowIdx]) {\n          const value = col.data[col.rowKeys[rowIdx]];\n          // Convert value to string, handling different types\n          if (value === null || value === undefined || value === '[undefined]') {\n            rowValues.push('');\n          } else if (typeof value === 'object') {\n            rowValues.push(JSON.stringify(value));\n          } else {\n            rowValues.push(String(value));\n          }\n        } else {\n          rowValues.push('');\n        }\n      });\n      \n      // Add row if it has any content\n      const rowStr = rowValues.join('\\t');\n      if (rowStr.replace(/\\t/g, '').trim()) {\n        sheetContent += rowStr + '\\n';\n      }\n    }\n  } else if (Array.isArray(data) && data.length > 0) {\n    // Handle array of rows\n    data.forEach(row => {\n      if (row && typeof row === 'object') {\n        const values = Object.values(row).map(v => {\n          if (v === null || v === undefined) return '';\n          return String(v);\n        }).join('\\t');\n        if (values.trim()) {\n          sheetContent += values + '\\n';\n        }\n      }\n    });\n  }\n  \n  // Add sheet content if not empty\n  if (sheetContent.trim()) {\n    combinedText += `\\n=== ${fileName} ===\\n${sheetContent}`;\n    console.log(`Added content for ${fileName}, length: ${sheetContent.length}`);\n  }\n});\n\nif (!combinedText.trim()) {\n  throw new Error('No readable data extracted from Excel file');\n}\n\nconsole.log('Successfully extracted data');\nconsole.log('First 1000 chars:', combinedText.substring(0, 1000));\n\nreturn [{json: {spreadsheetData: combinedText}}];"
      },
      "id": "135982f2-8cb5-4f67-8841-d6a848e9dcee",
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4-turbo-preview",
          "mode": "list"
        },
        "messages": {
          "values": [
            {
              "content": "You are a financial data expert. Transform various financial statement formats into a standardized structure.\n\nYour task:\n1. Identify the type of statement (Income Statement, Balance Sheet, Cash Flow, etc.)\n2. Recognize the data structure (could be dates in columns, dates in rows, various layouts)\n3. Extract ALL data points and transform them\n\nOutput format - EVERY data point becomes a row with these exact columns:\n- \"Date Concat\": Month and year like \"Jan 2023\" or \"Dec 2023\" \n- \"Year\": Year as string like \"2023\"\n- \"Month\": Month number as string like \"1\" for January, \"12\" for December\n- \"Financial Statements\": The statement type (\"Income Statement\", \"Balance Sheet\", etc.)\n- \"Parent Account\": The category/grouping (\"Revenue\", \"COGS\", \"Assets\", \"Liabilities\", etc.)\n- \"Account\": The specific line item name\n- \"Attribute\": Date in M/D/YYYY format like \"1/1/2023\" or \"12/31/2023\"\n- \"Value\": Dollar amount with $ and commas like \"$123,456\" or \"-$123,456\"\n\nCommon patterns to recognize:\n- Excel serial dates (44927 = Dec 1, 2022, 45292 = Jan 1, 2023, 45657 = Dec 31, 2023)\n- Account names usually in first column or row\n- Dates might be in headers as months, quarters, or years\n- Values might be plain numbers that need $ formatting\n- Parent accounts might be explicitly shown or need to be inferred\n- \"Revenue Tier\" items belong to \"Revenue\" parent account\n- Look for \"Ending Dec 2024\", \"Ending Dec 2023\" as date indicators\n\nBe flexible - handle various formats but always output the same structure.\nReturn ONLY a valid JSON array, no explanations.",
              "role": "system"
            },
            {
              "content": "Transform this financial data into the standardized format:\n\n{{ $json.spreadsheetData }}\n\nAnalyze the structure, identify all accounts and time periods, and return a JSON array with every data point transformed."
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "maxTokens": 16000,
          "temperature": 0.2
        }
      },
      "id": "80561117-04b9-4e2a-804f-69a0358982f7",
      "name": "AI Transform",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.3,
      "position": [850, 300],
      "credentials": {
        "openAiApi": {
          "id": "fU0gBDv1oGgR7tvS",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate AI response\nconst input = $input.first().json;\nlet finalData = [];\n\nconsole.log('AI Response type:', typeof input);\n\n// Try various response formats\nif (Array.isArray(input)) {\n  finalData = input;\n} else if (typeof input === 'string') {\n  try {\n    finalData = JSON.parse(input);\n  } catch (e) {\n    console.error('Parse error:', e);\n  }\n} else if (input && typeof input === 'object') {\n  // Check for nested response\n  const possibleKeys = ['message', 'content', 'result', 'data', 'output'];\n  for (const key of possibleKeys) {\n    if (input[key]) {\n      try {\n        finalData = typeof input[key] === 'string' ? JSON.parse(input[key]) : input[key];\n        if (Array.isArray(finalData)) break;\n      } catch (e) {\n        continue;\n      }\n    }\n  }\n}\n\n// Ensure it's an array\nif (!Array.isArray(finalData)) {\n  console.error('Not an array:', finalData);\n  if (finalData && typeof finalData === 'object') {\n    finalData = [finalData];\n  } else {\n    finalData = [];\n  }\n}\n\n// Clean and validate\nconst cleaned = finalData\n  .filter(row => row && typeof row === 'object')\n  .map(row => ({\n    \"Date Concat\": String(row[\"Date Concat\"] || ''),\n    \"Year\": String(row[\"Year\"] || ''),\n    \"Month\": String(row[\"Month\"] || ''),\n    \"Financial Statements\": String(row[\"Financial Statements\"] || ''),\n    \"Parent Account\": String(row[\"Parent Account\"] || ''),\n    \"Account\": String(row[\"Account\"] || ''),\n    \"Attribute\": String(row[\"Attribute\"] || ''),\n    \"Value\": String(row[\"Value\"] || '')\n  }));\n\nconsole.log(`Returning ${cleaned.length} rows`);\n\nif (cleaned.length === 0) {\n  // Return empty array instead of throwing error\n  return [{json: {data: '[]'}}];\n}\n\nreturn [{json: {data: JSON.stringify(cleaned)}}];"
      },
      "id": "239e4b7b-b9da-4546-95f5-f7b50b12b830",
      "name": "Clean Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.data }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "d2922d5c-14a8-47f3-a431-41b2e3cd92f4",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1150, 300]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Fix Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fix Binary": {
      "main": [
        [
          {
            "node": "Read Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Excel": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "AI Transform",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Transform": {
      "main": [
        [
          {
            "node": "Clean Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Response": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "working-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "5d26e528731fd716b7a8a5b53957bd6f1a66e64993502643fd3ab51cc16063e3"
  },
  "id": "financial-processor-working",
  "tags": []
}