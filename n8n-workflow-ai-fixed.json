{
  "name": "Financial Processor with AI - Fixed",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-financials",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Excel files\nconst items = [];\nconst binaryData = $input.item.binary;\n\nif (!binaryData) {\n  return [{ json: { error: 'No files received' } }];\n}\n\nfor (const [key, file] of Object.entries(binaryData)) {\n  const buffer = await this.helpers.binaryToBuffer(file);\n  const XLSX = require('xlsx');\n  const workbook = XLSX.read(buffer);\n  \n  items.push({\n    json: {\n      fileName: file.fileName,\n      sheets: workbook.SheetNames,\n      workbook: JSON.stringify(workbook)\n    }\n  });\n}\n\nreturn items;"
      },
      "id": "parseExcel",
      "name": "Parse Excel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract data from sheets\nconst XLSX = require('xlsx');\nconst workbook = JSON.parse($input.item.json.workbook);\nconst allData = [];\n\nfor (const sheetName of $input.item.json.sheets) {\n  const sheet = workbook.Sheets[sheetName];\n  const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });\n  \n  // Detect statement type\n  let statementType = 'Unknown';\n  const sheetLower = sheetName.toLowerCase();\n  if (sheetLower.includes('income') || sheetLower.includes('p&l')) {\n    statementType = 'Income Statement';\n  } else if (sheetLower.includes('balance')) {\n    statementType = 'Balance Sheet';\n  }\n  \n  // Find header row\n  let headerRow = -1;\n  for (let i = 0; i < Math.min(10, data.length); i++) {\n    if (data[i] && data[i][0] === 'Code') {\n      headerRow = i;\n      break;\n    }\n  }\n  \n  if (headerRow === -1) continue;\n  \n  // Extract data\n  for (let i = headerRow + 1; i < data.length; i++) {\n    const row = data[i];\n    if (!row || !row[0] || !row[1]) continue;\n    \n    // Get values for each period column\n    for (let col = 2; col < row.length; col += 2) {\n      const value = row[col];\n      if (value === null || value === undefined || value === '') continue;\n      \n      allData.push({\n        statementType,\n        accountCode: row[0],\n        accountName: row[1],\n        value: parseFloat(value) || value,\n        percent: row[col + 1] || null,\n        periodColumn: col,\n        sourceSheet: sheetName\n      });\n    }\n  }\n}\n\nreturn [{ json: { extractedData: allData } }];"
      },
      "id": "extractData",
      "name": "Extract Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "resource": "chat",
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Transform financial data to this exact JSON structure. Return ONLY valid JSON, no explanations:\n{\n  \"data\": [\n    {\"date\": \"YYYY-MM-DD\", \"year\": YYYY, \"month\": MM, \"statementType\": \"string\", \"accountCode\": \"string\", \"accountName\": \"string\", \"value\": number, \"percent\": number}\n  ]\n}"
            },
            {
              "role": "user",
              "content": "Transform this data, use 2024-01-01 as default date if none found:\n{{ JSON.stringify($json.extractedData) }}"
            }
          ]
        },
        "options": {
          "temperature": 0.1,
          "maxTokens": 4000
        }
      },
      "id": "openai",
      "name": "OpenAI Transform",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.3,
      "position": [850, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse AI response and prepare output\nlet transformedData = [];\n\ntry {\n  // Get the AI response\n  const aiResponse = $input.item.json.message?.content || $input.item.json.choices?.[0]?.message?.content || '';\n  \n  // Try to parse JSON\n  let parsed;\n  \n  // Clean the response (remove markdown if present)\n  let cleanResponse = aiResponse;\n  if (cleanResponse.includes('```json')) {\n    cleanResponse = cleanResponse.split('```json')[1].split('```')[0];\n  } else if (cleanResponse.includes('```')) {\n    cleanResponse = cleanResponse.split('```')[1].split('```')[0];\n  }\n  \n  try {\n    parsed = JSON.parse(cleanResponse);\n    transformedData = parsed.data || parsed.transformedData || [];\n  } catch (e) {\n    // Fallback: use original data with basic transformation\n    const originalData = $input.all()[0].json.extractedData || [];\n    transformedData = originalData.map(item => ({\n      date: '2024-01-01',\n      year: 2024,\n      month: 1,\n      statementType: item.statementType || 'Unknown',\n      accountCode: String(item.accountCode || ''),\n      accountName: String(item.accountName || ''),\n      value: parseFloat(item.value) || 0,\n      percent: parseFloat(item.percent) || 0\n    }));\n  }\n} catch (error) {\n  // Ultimate fallback\n  transformedData = [{\n    date: '2024-01-01',\n    year: 2024,\n    month: 1,\n    statementType: 'Error',\n    accountCode: 'ERR',\n    accountName: 'Processing Error',\n    value: 0,\n    percent: 0\n  }];\n}\n\n// Create Excel\nconst XLSX = require('xlsx');\nconst ws = XLSX.utils.json_to_sheet(transformedData);\nconst wb = XLSX.utils.book_new();\nXLSX.utils.book_append_sheet(wb, ws, 'Raw Financials');\n\nconst buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });\n\nreturn [{\n  json: {\n    success: true,\n    totalRecords: transformedData.length,\n    data: transformedData\n  },\n  binary: {\n    excel: {\n      data: buffer.toString('base64'),\n      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      fileName: `raw_financials_${new Date().toISOString().split('T')[0]}.xlsx`\n    }\n  }\n}];"
      },
      "id": "prepareOutput",
      "name": "Prepare Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1250, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{"node": "Parse Excel", "type": "main", "index": 0}]]
    },
    "Parse Excel": {
      "main": [[{"node": "Extract Data", "type": "main", "index": 0}]]
    },
    "Extract Data": {
      "main": [[{"node": "OpenAI Transform", "type": "main", "index": 0}]]
    },
    "OpenAI Transform": {
      "main": [[{"node": "Prepare Output", "type": "main", "index": 0}]]
    },
    "Prepare Output": {
      "main": [[{"node": "Respond", "type": "main", "index": 0}]]
    }
  }
}
